<?php
/**
 * @file
 * Main conduit module file which provides primary Drupal hook implementations.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * Always return: status, messages, result.
 * Use client hash which should include client key + time + salt.
 */

/**
 * Implements hook_node_info().
 *
 * Client:
 *  - key
 * Worker:
 *  - key
 *  - plugins
 *
 * Group:
 *  - owner
 *  - parent
 *  - properties
 */
function conduit_node_info() {
  $info = array();

  $info['conduit_client'] = array(
    'name' => t('Conduit client'),
    'base' => 'conduit',
    'description' => t('Controls the conduit.'),
  );
  $info['conduit_worker'] = array(
    'name' => t('Conduit worker'),
    'base' => 'conduit',
    'description' => t('Performs queued jobs.'),
  );

  $info['conduit_group'] = array(
    'name' => t('Conduit group'),
    'base' => 'conduit',
    'description' => t('Groups jobs together and can be used to create a hierarchy.'),
  );
  $info['conduit_job'] = array(
    'name' => t('Conduit job'),
    'base' => 'conduit',
    'description' => t('Job to be performed.'),
  );

  return $info;
}

/**
 * Implements hook_form().
 */
function conduit_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function conduit_form_alter(&$form, &$form_state, $form_id) {
  // Check for conduit node form.
  foreach (array_keys(conduit_node_info()) as $type) {
    if ($form_id == $type . '_node_form') {
      $found = TRUE;
      break;
    }
  }

  // If not found then return.
  if (empty($found)) {
    return;
  }

  // Set title description using type.
  $type = str_replace('conduit_', '', $type);
  $form['title']['#description'] = t('Displayed when referencing @type.', array('@type' => $type));

  // Move all conduit fields into a fieldset.
  $form[$type] = array(
    '#type' => 'fieldset',
    '#title' => ucfirst(t('@type', array('@type' => $type))),
  );
  foreach (element_children($form) as $key) {
    if ($key == 'title' || strpos($key, 'conduit_') === 0) {
      $form[$type][$key] = $form[$key];
      unset($form[$key]);
    }
  }
}

/**
 * Implements hook_validate().
 */
function conduit_validate($node, $form = array()) {
  // If errors found by previous validation functions do not bother.
  if (form_get_errors()) {
    return;
  }

  // Check conduit key length.
  if (isset($node->conduit_key)) {
    $key = $node->conduit_key[LANGUAGE_NONE][0]['value'];
    if (drupal_strlen($key) < 32 || drupal_strlen($key) > 64) {
      form_set_error('conduit_key', t('Key must be at least 32 and no more then 64 characters in length.'));
    }
  }

  // Ensure properties are in valid php syntax.
  if (isset($node->conduit_properties)) {
    $properties = $node->conduit_properties[LANGUAGE_NONE][0]['value'];
    $properties = conduit_properties($properties);
    if (!is_array($properties)) {
      form_set_error('conduit_properties', t('Properties must be valid PHP syntax.'));
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function conduit_field_formatter_info() {
  return array(
    'conduit_properties' => array(
      'label' => t('Conduit properties'),
      'description' => t('Represent properties in an easy to read manor.'),
      'field types' => array('text_long'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function conduit_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'conduit_properties':
      foreach ($items as $delta => $item) {
        $element[$delta]['#type'] = 'markup';
        $properties = conduit_properties($item['value']);
        $element[$delta]['#markup'] = highlight_string('<?php ' . var_export($properties, TRUE), TRUE);
      }
      break;
  }

  return $element;
}

/**
 * Evaluate properties input string.
 *
 * @return
 *   Evaluated value.
 */
function conduit_properties($string) {
  return @eval('return array(' . $string . ');');
}

/**
 * Implements hook_xmlrpc().
 *
 * All methods require authentication hash as the first parameter and will
 * return the standard conduit return value.
 *
 * <code>
 *   return array(
 *     'status' => ['authentication', 'accepted', 'denied']
 *     'messages' => array( [messages explaining status and/or what was done.] ),
 *     'result' => array( [structured data array containing the result of the
 *                         requested opperation.] )
 *   );
 * </code>
 *
 * Methods:
 * - job.create(array job)
 * - job.queue(int job_id)
 * - job.status(array job_ids)
 * - job.summary(int job_id)
 * - job.detail(int job_id)
 * - job.delete(int job_id)
 * - group.create(array group)
 * - group.delete(int group_id)
 * - server.status()
 */
function conduit_xmlrpc() {
  conduit_include('xmlrpc');

  // List of provided methods.
  $methods = array(
    'job.create' => t('Create a job.'),
    'job.queue' => t('Place an existing job in the queue.'),
    'job.status' => t('Query the status of a job or list of jobs.'),
    'job.summary' => t('Retrieve the summary of the result of a job.'),
    'job.detail' => t('Retrieve the detailed result of a job.'),
    'job.delete' => t('Delete a job.'),
    'group.create' => t('Create a job group.'),
    'group.delete' => t('Delete a job group.'),
    'server.status' => t('Query the server status.'),
  );

  // Generate hook_xmlrpc() XML-RPC definitions.
  $xmlrpc = array();
  foreach ($methods as $method => $description) {
    $xmlrpc[$method] = array(
      'conduit.' . $method,
      'conduit_xmlrpc_' . str_replace('.', '_', $method),
      array('struct', 'string', 'int'),
      $description,
    );
  }

  // Remove the third parameter or change data-type based on API definitions.
  $xmlrpc['job.create'][2][2] = 'struct';
  $xmlrpc['job.status'][2][2] = 'array';
  $xmlrpc['group.create'][2][2] = 'struct';
  unset($xmlrpc['server.status'][2][2]);

  return $xmlrpc;
}

/**
 * Load a conduit include file.
 */
function conduit_include($include) {
  require_once 'includes/' . $include . '.inc';
}
