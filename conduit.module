<?php
/**
 * @file
 * Provides primary Drupal hook implementations.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * @mainpage Conduit
 * Conduit is a job distribution system.
 *
 * For information on the base job properties see the
 * @link worker_perform worker_perform() @endlink.
 */

/**
 * Always return: status, messages, result.
 * Use client hash which should include client key + time + salt.
 */

/**
 * Implements hook_permission().
 */
function conduit_permission() {
  $permissions = array();

  foreach (array('meta', 'status', 'result') as $fieldset) {
    $permissions['edit conduit job ' . $fieldset] = array(
      'title' => t('Edit conduit job @fieldset information.', array('@fieldset' => $fieldset)),
      'description' => t('Edit the fields conntained within the @fieldset fieldset.', array('@fieldset' => $fieldset)),
    );
  }

  return $permissions;
}

/**
 * Implements hook_node_info().
 */
function conduit_node_info() {
  $info = array();

  $info['conduit_client'] = array(
    'name' => t('Conduit client'),
    'base' => 'conduit',
    'description' => t('Controls the conduit.'),
  );
  $info['conduit_group'] = array(
    'name' => t('Conduit group'),
    'base' => 'conduit',
    'description' => t('Groups jobs together and can be used to create a hierarchy.'),
  );
  $info['conduit_worker'] = array(
    'name' => t('Conduit worker'),
    'base' => 'conduit',
    'description' => t('Performs queued jobs.'),
  );

  return $info;
}

/**
 * Generate job node type definition for a plugin.
 *
 * @param $plugin
 *   Plugin name.
 * @return
 *   Node type definition to be used with hook_node_info().
 * @see hook_node_info()
 */
function conduit_node_info_job($plugin) {
  return array(
    'conduit_job_execute' => array(
      'name' => t('Conduit job - @plugin', array('@plugin' => $plugin)),
      'base' => 'conduit',
      'description' => t('Job, of type @plugin, to be performed.', array('@plugin' => $plugin)),
    ),
  );
}

/**
 * Implements hook_form().
 */
function conduit_form($node, &$form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function conduit_form_alter(&$form, &$form_state, $form_id) {
  // Check for conduit node form.
  if (strpos($form_id, 'conduit') !== 0) {
    return;
  }

  // Set title description using type.
  $form['title']['#description'] = t('Displayed when being referencing.');

  // If key is present, but not set the create a random key.
  if (isset($form['conduit_key']) && empty($form['conduit_key'][LANGUAGE_NONE][0]['value']['#default_value'])) {
    $form['conduit_key'][LANGUAGE_NONE][0]['value']['#default_value'] = md5(mt_rand(1000, 1000000000));
  }

  // Move all conduit fields into a fieldset.
  $job = strpos($form_id, 'conduit_job') === 0;
  $fieldsets = $job ? array('meta', 'status', 'result') : array('meta');
  foreach ($fieldsets as $fieldset) {
    $form['conduit_' . $fieldset] = array(
      '#type' => 'fieldset',
      '#title' => ucfirst($fieldset),
      '#collapsible' => TRUE,
      '#collapsed' => $fieldset != 'meta',
      '#access' => user_access('edit conduit job ' . $fieldset),
    );
  }

  $status = array('conduit_done', 'conduit_chunk_count');
  $result = array('conduit_pass', 'conduit_summary', 'conduit_chunk_pass', 'conduit_log');
  foreach (element_children($form) as $key) {
    if (isset($form[$key]['#type']) && $form[$key]['#type'] == 'fieldset') {
      continue;
    }

    if ($key == 'title' || strpos($key, 'conduit_') === 0) {
      $fieldset = 'meta';
      if ($job) {
        if (in_array($key, $status)) {
          $fieldset = 'status';
        }
        elseif (in_array($key, $result) || strpos($key, 'conduit_result') === 0) {
          $fieldset = 'result';
        }
      }

      $form['conduit_' . $fieldset][$key] = $form[$key];
      unset($form[$key]);
    }
  }
}

/**
 * Implements hook_node_load().
 *
 * All the conduit specific data should already be loaded, but some of it
 * requires processing and all the conduit data will be placed in an easy to
 * access format instead of the abstract field api format for reading. This has
 * to be done in hook_node_load() instead of hook_load() since fields are not
 * present in hook_load().
 */
function conduit_node_load($nodes, $types) {
  // Look for any conduit types among the list of node types.
  $found = FALSE;
  foreach ($types as $type) {
    if (strpos($type, 'conduit') === 0) {
      $found = TRUE;
      break;
    }
  }
  // Only process nodes if a conduit type is present.
  if (!$found) {
    return;
  }

  foreach ($nodes as $node) {
    // Ensure the current node is a conduit node.
    if (strpos($node->type, 'conduit') !== 0) {
      continue;
    }
    $node->conduit = array();
    $fields = array('key', 'owner', 'parent', 'properties', 'done', 'chunk_count', 'pass');
    foreach ($fields as $field) {
      $key = 'conduit_' . $field;
      if (!empty($node->$key)) {
        $value = $node->$key;
        $node->conduit[$field] = $value[LANGUAGE_NONE][0][$field == 'owner' || $field == 'parent' ? 'nid' : 'value'];
      }
    }

    // If the properties field has a value then parse the value, otherwise
    // initialize the properties attribute if applicable.
    if (isset($node->conduit['properties'])) {
      $node->conduit['properties'] = conduit_properties($node->conduit['properties']);
    }
    elseif ($node->type != 'conduit_worker') {
      $node->conduit['properties'] = array();
    }

    // If chunk_pass field is defined then entire the attribute is initialized
    // and if it has values then simplify them and place in attribute.
    if (isset($node->conduit_chunk_pass)) {
      $node->conduit['chunk_pass'] = array();
      if (!empty($node->conduit_chunk_pass)) {
        foreach ($node->conduit_chunk_pass[LANGUAGE_NONE] as $key => $chunk) {
          $node->conduit['chunk_pass'][$key] = $chunk['value'];
        }
      }
    }
  }
}

/**
 * Implements hook_validate().
 */
function conduit_validate($node, $form = array(), &$form_state) {
  // Check conduit key length.
  if (isset($node->conduit_key)) {
    $key = $node->conduit_key[LANGUAGE_NONE][0]['value'];
    if (drupal_strlen($key) < 32 || drupal_strlen($key) > 64) {
      form_set_error('conduit_key', t('The key field must be at least 32 and no more then 64 characters in length.'));
    }
  }

  // Ensure properties are in valid php syntax.
  if (isset($node->conduit_properties)) {
    $properties = $node->conduit_properties[LANGUAGE_NONE][0]['value'];

    // Ensure the properties string contains only allowed tokens, ignoring the
    // first token which will be the <?php token.
    $tokens = token_get_all('<?php ' . $properties);
    array_shift($tokens);
    $allowed = array(T_ARRAY, T_CONSTANT_ENCAPSED_STRING, T_DNUMBER, T_DOUBLE_ARROW, T_LNUMBER, T_STRING, T_WHITESPACE);
    $valid = TRUE;
    foreach ($tokens as $token) {
      if (is_array($token) && !in_array($token[0], $allowed)) {
        $valid = FALSE;
        break;
      }
    }

    // If the properties string contains only valid tokens then attempt to
    // evaluate it as a a PHP array, otherwise display an error.
    if ($valid) {
      $properties = conduit_properties($properties);
      if (!is_array($properties)) {
        form_set_error('conduit_properties', t('The properties field must contain valid PHP syntax.'));
      }
    }
    else {
      form_set_error('conduit_properties', t('The properties field may only contain arrays, numbers, strings, or whitespace.'));
    }
  }
}

/**
 * Implements hook_insert().
 */
function conduit_insert($node) {
  if (strpos($node->type, 'conduit_job') === 0) {
    // Since the node is brand new it will not have the ->conduit property
    // which is used throughout the API, so force a load.
    conduit_node_load(array($node), array($node->type));
    conduit_include('queue');

    // Create the queue items for the job and thus the number of chunks.
    $chunk_count = conduit_queue_create($node);

    // Initialize job fields and insert placeholder values into all multivalued
    // chunk fields to ensure the results can be inserted in any order.
    $node->conduit_done[LANGUAGE_NONE][0]['value'] = (int) FALSE;
    $node->conduit_chunk_count[LANGUAGE_NONE][0]['value'] = $chunk_count;
    $node->conduit_pass[LANGUAGE_NONE][0]['value'] = -1;
    $node->conduit_summary[LANGUAGE_NONE][0]['value'] = t('The job has not yet been performed.');
    for ($i = 0; $i < $chunk_count; $i++) {
      $node->conduit_chunk_pass[LANGUAGE_NONE][$i]['value'] = -1;
      $node->conduit_log[LANGUAGE_NONE][$i]['value'] = '[placeholder]';
    }

    // Since the plugin stores its results it must initialize its field(s).
    module_invoke($node->conduit['properties']['plugin'], 'conduit_init', $node, $chunk_count);
  }
}

/**
 * Implements hook_update().
 */
function conduit_update($node) {
  // If a new revision is being generated then process the new job.
  if (isset($node->old_vid)) {
    conduit_insert($node);
  }
}

/**
 * Implements hook_view().
 */
function conduit_view($node, $view_mode) {
  if ($view_mode == 'full' && node_is_page($node)) {
    // Add a breakcrumb on group or job nodes.
    if ($node->type == 'conduit_group' || strpos($node->type, 'conduit_job') === 0) {
      // The breadcrumbs are order top-down, but drupal_set_breadcrumb() will
      // display them left-to-right so we need to reverse order and remove the
      // current node from the list.
      $breadcrumb = array_reverse(conduit_view_breadcrumb($node));
      array_pop($breadcrumb);
      drupal_set_breadcrumb($breadcrumb);
    }

    // Add a list of group on client or group nodes.
    if ($node->type == 'conduit_client' || $node->type == 'conduit_group') {
      $view = views_get_view('conduit_group');
      $view->override_path = $_GET['q'];
      $node->content['conduit_group'] = array(
        '#markup' => $view->preview('defualt', array($node->nid)),
        '#weight' => 10,
      );

      $view = views_get_view('conduit_job');
      $view->override_path = $_GET['q'];
      $node->content['conduit_job'] = array(
        '#markup' => $view->preview('defualt', array($node->nid)),
        '#weight' => 11,
      );
    }
  }
  return $node;
}

/**
 * Generate a set of breadcrumb links from the top node down.
 *
 * @param $node
 *   Top node in tree.
 * @param $breadcrumb
 *   (Optional) Used internally to keep track of breadcrumbs.
 * @return
 *   A list of links ordered from the top node down.
 */
function conduit_view_breadcrumb($node, $breadcrumb = array()) {
  // Add the current node to the breadcrumb.
  $breadcrumb[] = l($node->title, 'node/' . $node->nid);

  // If the node has a parent the recurse.
  if (!empty($node->conduit['parent'])) {
    $breadcrumb = conduit_view_breadcrumb(node_load($node->conduit['parent']), $breadcrumb);
  }
  return $breadcrumb;
}

/**
 * Implements hook_field_formatter_info().
 */
function conduit_field_formatter_info() {
  return array(
    'conduit_properties' => array(
      'label' => t('Conduit properties'),
      'description' => t('Represent properties in an easy to read manner.'),
      'field types' => array('text_long'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function conduit_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'conduit_properties':
      foreach ($items as $delta => $item) {
        $properties = conduit_properties($item['value']);
        $element[$delta]['#type'] = 'markup';
        $element[$delta]['#markup'] = highlight_string('<?php ' . var_export($properties, TRUE), TRUE);
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_node_view_alter().
 *
 * Add the inherited, or merged, display of properties to the node view.
 */
function conduit_node_view_alter(&$build) {
  if ($build['#view_mode'] == 'full' && isset($build['conduit_properties'])) {
    $properties_inherit = conduit_properties_merge($build['#node']);
    if ($build['#node']->conduit['properties'] != $properties_inherit) {
      $build['conduit_properties_inherit'] = array(
        '#type' => 'markup',
        '#markup' => highlight_string('<?php ' . var_export($properties_inherit, TRUE), TRUE),
        '#weight' => $build['conduit_properties']['#weight'] + 0.1,
      );
    }
  }
}

/**
 * Evaluate properties input string.
 *
 * @return
 *   Evaluated value.
 */
function conduit_properties($string) {
  return @eval('return array(' . $string . ');');
}

/**
 * Merge group and default properties together with entity's properties.
 *
 * The properties are merged in such a way that the lower the item is on the
 * list the more precedence it has and will those override any properties with
 * the same key from above. The order is as follows: defaults, groups, and job.
 * A tree of groups will be treated in same manor with the root group having
 * the least precedence.
 *
 * @param $entity
 *   Either a group or job node.
 * @return
 *   Associative array of properties.
 */
function conduit_properties_merge($entity) {
  // Start with the properties of the entity.
  $properties = $entity->conduit['properties'];

  // Find the relevant parent group or client the entity belongs to, then
  // recurse through the group tree and merge the properties with those of the
  // entity. If the entity is a client then it is the root element and thus
  // does not belong to a group.
  if ($entity->type == 'conduit_group' || strpos($entity->type, 'conduit_job') === 0) {
    $properties = conduit_properties_recurse_groups(node_load($entity->conduit['parent']), $properties);
  }

  // If the merged list of properties contains a plugin key (all jobs must)
  // then merge the default properties specified by the plugin with the rest of
  // the properties.
  if (!empty($properties['plugin'])) {
    $default_properties = module_invoke($properties['plugin'], 'conduit_default_properties');
    $properties = array_replace_recursive($default_properties, $properties);
  }
  return $properties;
}

/**
 * Recursively merge the properties of a group hierarchy.
 *
 * @param $group
 *   The current group node being processed.
 * @param $properties
 *   The current array of merged properties.
 * @return
 *   Associative array of properties.
 */
function conduit_properties_recurse_groups($group, array $properties = array()) {
  $properties = array_replace_recursive($group->conduit['properties'], $properties);
  if (!empty($group->conduit['parent'])) {
    $properties = conduit_properties_recurse_groups(node_load($group->conduit['parent']), $properties);
  }
  return $properties;
}

/**
 * Implements hook_views_api().
 */
function conduit_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'conduit') . '/views',
  );
}

/**
 * Implements hook_xmlrpc().
 *
 * All methods require authentication hash as the first parameter and will
 * return the standard conduit return value.
 *
 * <code>
 *   return array(
 *     'status' => ['authentication', 'accepted', 'denied']
 *     'messages' => array( [messages explaining status and/or what was done.] ),
 *     'result' => array( [structured data array containing the result of the
 *                         requested opperation.] )
 *   );
 * </code>
 *
 * Methods:
 * - job.create(array job)
 * - job.queue(int job_id)
 * - job.status(array job_ids)
 * - job.summary(int job_id)
 * - job.detail(int job_id)
 * - job.delete(int job_id)
 * - group.create(array group)
 * - group.delete(int group_id)
 * - server.status()
 */
function conduit_xmlrpc() {
  conduit_include('xmlrpc');

  // List of provided methods.
  $methods = array(
    'job.create' => t('Create a job.'),
    'job.queue' => t('Place an existing job in the queue.'),
    'job.status' => t('Query the status of a job or list of jobs.'),
    'job.summary' => t('Retrieve the summary of the result of a job.'),
    'job.detail' => t('Retrieve the detailed result of a job.'),
    'job.delete' => t('Delete a job.'),
    'group.create' => t('Create a job group.'),
    'group.delete' => t('Delete a job group.'),
    'server.status' => t('Query the server status.'),
  );

  // Generate hook_xmlrpc() XML-RPC definitions.
  $xmlrpc = array();
  foreach ($methods as $method => $description) {
    $xmlrpc[$method] = array(
      'conduit.' . $method,
      'conduit_xmlrpc_' . str_replace('.', '_', $method),
      array('struct', 'string', 'int'),
      $description,
    );
  }

  // Remove the third parameter or change data-type based on API definitions.
  $xmlrpc['job.create'][2][2] = 'struct';
  $xmlrpc['job.status'][2][2] = 'array';
  $xmlrpc['group.create'][2][2] = 'struct';
  unset($xmlrpc['server.status'][2][2]);

  return array_values($xmlrpc);
}

/**
 * Load a conduit include file.
 *
 * @param $include
 *   Name of include file, exluding the .inc.
 */
function conduit_include($include) {
  require_once drupal_get_path('module', 'conduit') . '/includes/' . $include . '.inc';
}
