<?php
/**
 * @file
 * Provides primary Drupal hook implementations.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * @mainpage Conduit
 * Conduit is a job distribution system.
 *
 * For information on the base job properties see the
 * @link worker_perform worker_perform() @endlink.
 */

/**
 * Always return: status, messages, result.
 * Use client hash which should include client key + time + salt.
 */

/**
 * Implements hook_hook_info().
 *
 * Load node.inc so node hooks are cached.
 */
function conduit_hook_info() {
  conduit_include('node');
}

/**
 * Implements hook_permission().
 */
function conduit_permission() {
  $permissions = array();

  foreach (array('meta', 'status', 'result') as $fieldset) {
    $permissions['edit conduit job ' . $fieldset] = array(
      'title' => t('Edit conduit job @fieldset information.', array('@fieldset' => $fieldset)),
      'description' => t('Edit the fields conntained within the @fieldset fieldset.', array('@fieldset' => $fieldset)),
    );
  }

  return $permissions;
}

/**
 * Implements hook_node_info().
 */
function conduit_node_info() {
  conduit_include('node');
  $info = array();

  $info['conduit_client'] = array(
    'name' => t('Conduit client'),
    'base' => 'conduit',
    'description' => t('Controls the conduit.'),
  );
  $info['conduit_group'] = array(
    'name' => t('Conduit group'),
    'base' => 'conduit',
    'description' => t('Groups jobs together and can be used to create a hierarchy.'),
  );
  $info['conduit_worker'] = array(
    'name' => t('Conduit worker'),
    'base' => 'conduit',
    'description' => t('Performs queued jobs.'),
  );

  return $info;
}

/**
 * Generate job node type definition for a plugin.
 *
 * @param $plugin
 *   Plugin name.
 * @return
 *   Node type definition to be used with hook_node_info().
 * @see hook_node_info()
 */
function conduit_node_info_job($plugin) {
  $title = ucfirst(str_replace('_', ' ', $plugin));
  return array(
    'conduit_job_' . $plugin => array(
      'name' => t('Conduit job - @plugin', array('@plugin' => $title)),
      'base' => 'conduit',
      'description' => t('Job, of type @plugin, to be performed.', array('@plugin' => $title)),
    ),
  );
}

/**
 * Merge group and default properties together with entity's properties.
 *
 * The properties are merged in such a way that the lower the item is on the
 * list the more precedence it has and will those override any properties with
 * the same key from above. The order is as follows: defaults, groups, and job.
 * A tree of groups will be treated in same manor with the root group having
 * the least precedence.
 *
 * @param $entity
 *   Either a group or job node.
 * @return
 *   Associative array of properties.
 */
function conduit_properties_merge($entity) {
  // Start with the properties of the entity.
  $properties = !empty($entity->conduit_properties) ? $entity->conduit_properties[LANGUAGE_NONE][0]['value'] : array();

  // If the entity is a job then merge the default properties specified by the
  // plugin with the rest of the properties. Add the plugin property based on
  // job type.
  if ($info = conduit_job_info($entity->type)) {
    $default_properties = module_invoke($info['module'], 'conduit_default_properties');
    $properties = array_replace_recursive($default_properties, $properties);
    $properties['plugin'] = $info['plugin'];
  }

  // Find the relevant parent group or client the entity belongs to and merge
  // its merged properties array with the current entity.
  if (!empty($entity->conduit_parent)) {
    $parent = node_load($entity->conduit_parent[LANGUAGE_NONE][0]['nid']);
    $properties = array_replace_recursive($parent->conduit_properties_merged, $properties);
  }

  return $properties;
}

/**
 * Determine job information based on the node type.
 *
 * @param $type
 *   Node type.
 * @return
 *   An associative array with the keys: module, category, and plugin,
 *   otherwise FALSE if the node type does not represent a job.
 */
function conduit_job_info($type) {
  if (strpos($type, 'conduit_job') === 0) {
    // All job node types should be in the form conduit_job_CATEGORY_PLUGIN.
    list(, , $category, $plugin) = explode('_', $type);
    return array(
      'module' => $category . '_' . $plugin,
      'category' => $category,
      'plugin' => $plugin,
    );
  }
  return FALSE;
}

/**
 * Implements hook_flush_caches().
 *
 * When any modules are enabled rebuild the list of allowed_values for
 * conduit_category to ensure it is up-to-date.
 */
function conduit_flush_caches() {
  // Determine the categories available given the job node types.
  $types = array_keys(node_type_get_types());
  $categories = array();
  foreach ($types as $type) {
    if ($info = conduit_job_info($type)) {
      $categories[$info['category']] = ucfirst($info['category']);
    }
  }

  // Build list of allowed values.
  $allowed_values = '';
  foreach ($categories as $category => $title) {
    $allowed_values .= "$category|$title\n";
  }
  $allowed_values = trim($allowed_values);

  // Grab the field definition, check for changes to the allowed_values, and
  // if changed then update the conduit_category field.
  $field = current(field_read_fields(array('field_name' => 'conduit_category')));
  if ($field['settings']['allowed_values'] != $allowed_values) {
    $field['settings']['allowed_values'] = $allowed_values;
    field_update_field($field);

    // Ensure queues for each category exist.
    foreach ($categories as $category) {
      DrupalQueue::get('conduit_job_' . $category)->createQueue();
    }

    // Keep a list of all categories ever used for cleanup during uninstall.
    $all_categories = variable_get('conduit_categories', array());
    $categories = drupal_map_assoc($categories);
    variable_set('conduit_categories', array_merge($all_categories, $categories));
  }
}

/**
 * Implements hook_views_api().
 */
function conduit_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'conduit') . '/views',
  );
}

/**
 * Implements hook_xmlrpc().
 *
 * All methods require authentication hash as the first parameter and will
 * return the standard conduit return value.
 *
 * <code>
 *   return array(
 *     'status' => ['authentication', 'accepted', 'denied']
 *     'messages' => array( [messages explaining status and/or what was done.] ),
 *     'result' => array( [structured data array containing the result of the
 *                         requested opperation.] )
 *   );
 * </code>
 *
 * Methods:
 * - job.create(array job)
 * - job.queue(int job_id)
 * - job.status(array job_ids)
 * - job.summary(int job_id)
 * - job.detail(int job_id)
 * - job.delete(int job_id)
 * - group.create(array group)
 * - group.delete(int group_id)
 * - server.status()
 */
function conduit_xmlrpc() {
  conduit_include('xmlrpc');

  // List of provided methods.
  $methods = array(
    'job.create' => t('Create a job.'),
    'job.queue' => t('Place an existing job in the queue.'),
    'job.status' => t('Query the status of a job or list of jobs.'),
    'job.summary' => t('Retrieve the summary of the result of a job.'),
    'job.detail' => t('Retrieve the detailed result of a job.'),
    'job.delete' => t('Delete a job.'),
    'group.create' => t('Create a job group.'),
    'group.delete' => t('Delete a job group.'),
    'server.status' => t('Query the server status.'),
  );

  // Generate hook_xmlrpc() XML-RPC definitions.
  $xmlrpc = array();
  foreach ($methods as $method => $description) {
    $xmlrpc[$method] = array(
      'conduit.' . $method,
      'conduit_xmlrpc_' . str_replace('.', '_', $method),
      array('struct', 'string', 'int'),
      $description,
    );
  }

  // Remove the third parameter or change data-type based on API definitions.
  $xmlrpc['job.create'][2][2] = 'struct';
  $xmlrpc['job.status'][2][2] = 'array';
  $xmlrpc['group.create'][2][2] = 'struct';
  unset($xmlrpc['server.status'][2][2]);

  return array_values($xmlrpc);
}

/**
 * Load a conduit include file.
 *
 * @param $include
 *   Name of include file, exluding the .inc.
 */
function conduit_include($include) {
  require_once drupal_get_path('module', 'conduit') . '/includes/' . $include . '.inc';
}
