<?php
/**
 * @file
 * Provides primary Drupal hook implementations.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * @mainpage Conduit
 * Conduit is a job distribution system.
 *
 * For information on the base job properties see the
 * @link worker_perform worker_perform() @endlink.
 */

/**
 * Status of job: failed during setup.
 */
define('CONDUIT_STATUS_SETUP', 1);

/**
 * Status of job: plugin encountered a failure.
 */
define('CONDUIT_STATUS_FAIL', 2);

/**
 * Status of job: pluging passed.
 */
define('CONDUIT_STATUS_PASS', 3);

conduit_include('node');

/**
 * Implements hook_permission().
 */
function conduit_permission() {
  $permissions = array();

  $permissions['view conduit log'] = array(
    'title' => t('View log'),
    'description' => t('View the log for a job.'),
  );

  // Worker permissions.
  $permissions['claim conduit item'] = array(
    'title' => t('Claim an item'),
    'description' => t('Claim an item from a category queue. <em>Required by all workers.</em>'),
  );
  $permissions['result conduit item'] = array(
    'title' => t('Store a result for an item'),
    'description' => t('Store a chunk result. <em>Required by all workers.</em>'),
  );

  return $permissions;
}

/**
 * Implements hook_user_view().
 */
function conduit_user_view($account, $view_mode, $langcode) {
  if ($view_mode == 'full' && in_array('conduit client', $account->roles)) {
    $view = views_get_view('conduit_group_user');
    $view->override_path = $_GET['q'];
    $account->content['conduit_group'] = array(
      '#markup' => $view->preview('default', array($account->uid)),
      '#weight' => 10,
    );
  }
}

/**
 * Implements hook_block_info().
 */
function conduit_block_info() {
  return array(
    'conduit' => array(
      'info' => t('conduit'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
      'status' => 1,
      'region' => 'sidebar_first',
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function conduit_block_view($delta = '') {
  $block = array();

  $router_item = menu_get_item($_GET['q']);
  if ($router_item['path'] == 'node/%' && ($node = menu_get_object()) && conduit_node_type($node->type)) {
    if ($node->type == 'conduit_group') {
      $parent = $node->nid;
      $block['subject'] = t('Add child');
    }
    else {
      $parent = $node->conduit_parent[LANGUAGE_NONE][0]['nid'];
      $block['subject'] = t('Add sibling');
    }

    $links = array();
    foreach (conduit_types() as $type => $name) {
      $links[] = l(t($name), 'node/add/' . str_replace('_', '-', $type), array('query' => array('parent' => $parent)));
    }
    $block['content'] = theme('item_list', array('items' => $links));
  }

  return $block;
}

/**
 * Implements hook_flush_caches().
 */
function conduit_flush_caches() {
  // Rebuild client role permissions.
  if ($role = user_role_load_by_name('conduit client')) {
    user_role_grant_permissions($role->rid, conduit_client_permissions());
  }
}

/**
 * Implements hook_conduit_default_properties().
 */
function conduit_conduit_default_properties() {
  return array(
    'context' => 3,
    'mask' => '/.*/',
    'newline' => 'unix',
    'nomask' => '/(\.\.?|CVS)$/',
    'patch' => array(),
    'path' => array(''),
    'setup' => array(),
    'ssh' => array(),
    'vcs' => array(),
    'verbose' => FALSE,
  );
}

/**
 * Merge group and default properties together with entity's properties.
 *
 * The properties are merged in such a way that the lower the item is on the
 * list the more precedence it has and will those override any properties with
 * the same key from above. The order is as follows: defaults, groups, and job.
 * A tree of groups will be treated in same manor with the root group having
 * the least precedence.
 *
 * Order[group]: base_defaults, (optional) parents(s), self.
 * Order[job]: base_defaults, plugin_defaults, parents(s), self.
 *
 * @param $node
 *   Either a group or job node.
 * @return
 *   Associative array of properties.
 */
function conduit_properties_merge($node) {
  // Always start with the base defaults.
  $properties = module_invoke('conduit', 'conduit_default_properties');

  // If the node is a job then merge the plugin defaults.
  if ($info = conduit_job_info($node->type)) {
    $plugin_defaults = module_invoke($info['module'], 'conduit_default_properties');
    $properties = array_replace_recursive($properties, $plugin_defaults);
  }

  // If the node has a parent then merge its merged properties array.
  if (!empty($node->conduit_parent) && ($parent = node_load($node->conduit_parent[LANGUAGE_NONE][0]['nid']))) {
    $properties = array_replace_recursive($properties, $parent->conduit_properties_merged);
  }

  // Merge the entity's properties.
  $self = !empty($node->conduit_properties) ? $node->conduit_properties[LANGUAGE_NONE][0]['value'] : array();
  $properties = array_replace_recursive($properties, $self);

  // If the node is a job then assign the plugin value.
  if ($info) {
    $properties['plugin'] = $info['plugin'];
  }

  return $properties;
}

/**
 * Determine job information based on the node type.
 *
 * @param $type
 *   Node type.
 * @return
 *   An associative array with the keys: module, category, and plugin,
 *   otherwise FALSE if the node type does not represent a job.
 */
function conduit_job_info($type) {
  if (!($info = &drupal_static(__FUNCTION__))) {
    $info = ($cache = cache_get(__FUNCTION__)) ? $cache->data : array();
  }

  if (!isset($info[$type])) {
    if (strpos($type, 'conduit_job') === 0) {
      // All job node types should be in the form conduit_job_CATEGORY_PLUGIN.
      list(, , $category, $plugin) = explode('_', $type);
      $info[$type] = array(
        'module' => $category . '_' . $plugin,
        'category' => $category,
        'plugin' => $plugin,
      );
      cache_set(__FUNCTION__, $info);
    }
    else {
      $info[$type] = FALSE;
    }
  }

  return $info[$type];
}

/**
 * Determine the conduit categories available given the job node types.
 *
 * @return
 *   Associative array of categories.
 */
function conduit_categories() {
  if (!($categories = &drupal_static(__FUNCTION__))) {
    $categories = ($cache = cache_get(__FUNCTION__)) ? $cache->data : array();
  }

  if (!$categories) {
    $types = array_keys(node_type_get_names());
    foreach ($types as $type) {
      if ($info = conduit_job_info($type)) {
        $categories[$info['category']] = $info['category'];
      }
    }
    cache_set(__FUNCTION__, $categories);
  }

  return $categories;
}

/**
 * Determine the conduit node types available.
 *
 * @see conduit_node_type()
 */
function conduit_types() {
  if (!($types = &drupal_static(__FUNCTION__))) {
    $types = ($cache = cache_get(__FUNCTION__)) ? $cache->data : array();
  }

  if (!$types) {
    $types = array_flip(array_filter(array_flip(node_type_get_names()), 'conduit_node_type'));
    cache_set(__FUNCTION__, $types);
  }

  return $types;
}

/**
 * Build a list of the client role permissions.
 *
 * @return
 *   List of client role permissions.
 */
function conduit_client_permissions() {
  $types = array_filter(array_keys(node_type_get_names()), 'conduit_node_type');
  $operations = array('create', 'edit own', 'delete own');
  $permissions = array();
  foreach ($types as $type) {
    foreach ($operations as $operation) {
      $permissions[] = "$operation $type content";
    }
  }
  return $permissions;
}

/**
 * Implements hook_views_api().
 */
function conduit_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'conduit') . '/views',
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function conduit_ctools_plugin_api($owner, $api) {
  if ($owner == 'services' && $api == 'services') {
    conduit_include('services');
    return array('version' => 3);
  }
}

/**
 * Load a conduit include file.
 *
 * @param $include
 *   Name of include file, exluding the .inc.
 */
function conduit_include($include) {
  require_once drupal_get_path('module', 'conduit') . '/includes/' . $include . '.inc';
}
